
### Datastore Setup: MongoDB

This section highlights the rationale behind choosing MongoDB for storing simulated call records and details the setup process using the `calls_data_ingest.py` script.

### Why MongoDB?

- **Document-Oriented Model**  
  MongoDB’s JSON-like documents map directly to Python dictionaries, making it easy to handle the data generated by `make_call_record()`—no need for an ORM. It also supports nested and dynamic schemas naturally.

- **Schema Flexibility**  
  Call records can vary (e.g., missed calls won’t have a duration), and MongoDB lets each document be different without requiring schema migrations or introducing downtime.

- **Scalability & Performance**  
  With built-in horizontal sharding and replica sets, MongoDB can ingest thousands or even millions of call records efficiently, maintaining speed and reliability even under heavy load.

- **Native Date/Time Support**  
  Python datetime objects like `start_time` and `end_time` convert seamlessly to BSON date types, enabling optimized range queries and effective time-series analysis.

- **Rich Query & Indexing Capabilities**  
  MongoDB supports compound indexes—such as on `start_time + status`—which speed up filtering. Its aggregation framework allows grouping by date or status, and its native text search opens doors for future metadata-based exploration.

- **Seamless Python Integration**  
  With the lightweight `pymongo` driver, Python can easily interact with MongoDB. In fact, the `calls_data_ingest.py` script uses `MongoClient` to insert bulk records with a single command.

- **Cost-Effective Local Development**  
  MongoDB Community Edition runs locally or in a container with just one command. It’s free, simple to configure, and ideal for local development environments.

- **Ready for Real-Time Streaming**  
  MongoDB’s Change Streams feature allows real-time data to be piped directly into downstream tools—such as live Tableau dashboards—without rebuilding your existing pipeline.

---

### Setup Script: `calls_data_ingest.py`

- **Configure Connection**  
  The script reads the `MONGO_URI` (defaulting to `mongodb://localhost:27017`) and `NUM_CALLS` from environment variables to establish the database connection and control the number of simulated calls.

- **Generate Records**  
  It uses `Faker` for generating realistic phone numbers and `uuid.uuid4()` for unique call IDs. The generated dataset reflects practical distributions for call type, status, duration, and cost.

- **Bulk Insert**  
  All generated call documents are collected into a list and inserted into MongoDB using `insert_many()`. This minimizes network round-trips, improving performance.

- **Clean Shutdown**  
  Once all data is inserted, the MongoDB connection is closed properly to free up resources.
